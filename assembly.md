# 汇编学习

## 计算机基础原理

### 为什么负数要用补码表示？

	开始科学家想简化负数在运算中的处理，希望能像正数加法一样处理负数。
	计算的的数是有有效数字的，byte类型的整数的有效位数为8bit。
	以byte类型为例：
		如果果负数在内存中按原码表示（最高位为符号位），-1 为 1000 0001
		
		-1 = 1000 0001
	 +   2 = 0000 0010 （按正数加法处理）
	 ------------------
	    -3 = 1000 0011 
		
		结果是错的， 正确的应该是 1。
		
	要怎样才能得到 1 呢?
	很明显2+任何数都不可能得到1， 除非是溢出，即实际的和大于1，但受限于计算机中数的有效位数丢弃了和的最高位，如 257(1 0000 0001）。
    然后我们再反向用 257-2 得到该加什么数。
	
      257 = 1 0000 0001   (包含溢出位的1)
	-   2 =   0000 0010
	--------------------
      255 =   1111 1111   (按纯正数处理，不考虑符号位)
	 
	也就是说如果能把-1在内存中表示为255那就好了。
	
	-1 和 255 的关系是什么呢? 再看一下这不是小学学的同余定理么？
	
	(-1 + 2 ) mod 256 = 1
	(255 + 2) mod 256 = 1
	
	-1 和 255 就是差了一个模(256) 
	或说-1 补上了模就得到了一个计算机认为的等价正数了。
	因此我们把-1的等价正数，称为的它的补数。把-1编码为补数的表示方法，我们称之为补码。
	
	又因为根据算式表换
	-1 + 256 = 255
	256 = 255 + 1
	得到：
	    模 = 一个负数的绝对值 + 它的补数
	
	也就是说一个负数的补数就是： 一个加上它绝对值正好溢出的数。
	在二进制中这个数可以通过：
	    把这个负数的绝对值取反+1来得到。
		这也就是计算器获取一个负数补码的方法。
	    
### 基础寄存器
	
	在最早的8086cpu中，寄存器有8个，每个都有专门的用途。
	ax: accumulator for numeric operations (累加时用的)
	bx: base register (数组访问用的)
	cx: count register (记数用的，比方保存字符串的长度)
	dx: data register (保存通用数据用的）
	si: source index  (字符串复制时，用于保存源字符串的读偏移)
	di: destination index (字符串复制时，用于保存目的字符的写偏移)
	bp: base pointer (用于保存当前函数的栈帧首地址)
	sp: stack pointer (保持当前栈顶位置)
	
## 汇编语言

### yasm使用

	yasm 是一个能生成gdb兼容调试信息的汇编编译器。
	支持64bit的二进制的代码生成：  -f elf64
	支持dwarf2格式的调试信息生成： -g dwarf2
	
#### 什么是DWARF

	dwarf 是 Debugging with attributed record formats的缩写。
	是大多数编译器使用的调试信息存储格式。
	
### 基本命令

	segment .<段名>   段声明
	
	<变量名> db <值>   byte类型变量声明 (1byte)
	<变量名> dw <值>   word类型变量声明 (2byte)
	<变量名> dd <值>   double word类型变量声明 (4byte)
	<变量名> dq <值>   quad word类型变量声明(8byte)
	
	<值>可以是浮点数或普通整数。
	
	例如：
	           segment .data
	           a     dd       0.0
			   b     dd       122.5
			   

	mov <目标寄存器名> <常量>        移动常量到目标寄存器
	mov <目标寄存器名> [<地址>]      复制地址指向的值到目标寄存器
	mov <目标寄存器名> <源寄存器名>   移动源寄存器中的值到目标寄存器
	
	
    
	
	
	
