# 汇编学习

## 计算机基础原理

### 为什么负数要用补码表示？

	开始科学家想简化负数在运算中的处理，希望能像正数加法一样处理负数。
	计算的的数是有有效数字的，byte类型的整数的有效位数为8bit。
	以byte类型为例：
		如果果负数在内存中按原码表示（最高位为符号位），-1 为 1000 0001
		
		-1 = 1000 0001
	 +   2 = 0000 0010 （按正数加法处理）
	 ------------------
	    -3 = 1000 0011 
		
		结果是错的， 正确的应该是 1。
		
	要怎样才能得到 1 呢?
	很明显2+任何数都不可能得到1， 除非是溢出，即实际的和大于1，但受限于计算机中数的有效位数丢弃了和的最高位，如 257(1 0000 0001）。
    然后我们再反向用 257-2 得到该加什么数。
	
      257 = 1 0000 0001   (包含溢出位的1)
	-   2 =   0000 0010
	--------------------
      255 =   1111 1111   (按纯正数处理，不考虑符号位)
	 
	也就是说如果能把-1在内存中表示为255那就好了。
	
	-1 和 255 的关系是什么呢? 再看一下这不是小学学的同余定理么？
	
	(-1 + 2 ) mod 256 = 1
	(255 + 2) mod 256 = 1
	
	-1 和 255 就是差了一个模(256) 
	或说-1 补上了模就得到了一个计算机认为的等价正数了。
	因此我们把-1的等价正数，称为的它的补数。把-1编码为补数的表示方法，我们称之为补码。
	
	又因为根据算式表换
	-1 + 256 = 255
	256 = 255 + 1
	得到：
	    模 = 一个负数的绝对值 + 它的补数
	
	也就是说一个负数的补数就是： 一个加上它绝对值正好溢出的数。
	在二进制中这个数可以通过：
	    把这个负数的绝对值取反+1来得到。
		这也就是计算器获取一个负数补码的方法。
	    
### 为什么栈是从高地址向下增长的?
	
	在很早的时候，计算机内存就是分了代码段和栈空间区域的。

	对intelCPU来说，
	程序计数器(Program Counter)的缺省指向0地址，计算机开机后从程序计数器指向的地址开始执行程序，每执行完一条指令后， 程序计数器自动加1。
	因此很自然的，代码段从低地址区间开始加载，向高地址区间扩展；为了避免栈空间和代码段冲突，最大利用地址空间，很自然的，我们会选择把栈底设
	置在高地址区间，然后让栈向下增长。
		
	
### 基础寄存器
	
	在最早的8086cpu中，寄存器有8个，每个都有专门的用途。
	ax: accumulator for numeric operations (累加时用的)
	bx: base register (数组访问用的)
	cx: count register (记数用的，比方保存字符串的长度)
	dx: data register (保存通用数据用的）
	si: source index  (字符串复制时，用于保存源字符串的读偏移)
	di: destination index (字符串复制时，用于保存目的字符的写偏移)
	bp: base pointer (用于保存当前函数的栈帧首地址)
	sp: stack pointer (保持当前栈顶位置)
	
## 汇编语言

### 如何根据生成

### yasm使用

	yasm 是一个能生成gdb兼容调试信息的汇编编译器。
	使用yasm时需要指明生成的二进制文件格式：
		如果要生成64位的elf格式文件，需要指明参数 -f elf64
	如果需要生成gdb兼容的调试信息：
		则需要指明参数 -g dwarf2
	yasm还可以生成list文件。
		-l <输出的list文件名>
	
	yasm只能生成
#### 什么是listfile
	list文件是一个包含生成的机器码和汇编源码的对照文件。通过listfile能清晰地看懂生成的机器代码。
	assemble的file分为3列。　
		第一列为: list文件的行号
		第二列为: 生成的机器代码所在段内的偏移
		第三列为: 机器码对应的汇编源码
		
#### 什么是DWARF格式

	dwarf 是 Debugging with attributed record formats的缩写。
	是大多数编译器使用的调试信息存储格式。
	
	yasm支持的是dwarf2格式，该格式gdb也支持。
	

### 基本命令
	
  * segment .<段名>
	段声明
	
  * global <符号名>
	把符号标注为全局
	
  * <变量名> db <值>
	byte类型变量声明 (1byte)
		  
  * <变量名> dw <值>
	word类型变量声明 (2byte)
		
  * <变量名> dd <值>
	double word类型变量声明 (4byte) 可以是浮点数
			
  * <变量名> dq <值>
	quad word类型变量声明(8byte)
	
  * <变量名> resd <双字数> 
	为变量保留空间 resd(reserve double word)
	
  * <变量名> times [db|dw|dd|dq] <次数>
	times 用于为数组保留空间，db,dw,dd,dq为数组元素的类型，<次数>为数组长度。
	
  * <值>可以是浮点数或普通整数。
	
	例如：
	           segment .data
	           a     dd       0.0
			   b     dd       122.5
			   

	mov <目标寄存器名> <常量>        移动常量到目标寄存器
	mov <目标寄存器名> [<地址>]      复制地址指向的值到目标寄存器
	mov <目标寄存器名> <源寄存器名>   移动源寄存器中的值到目标寄存器
	
	
    
	
	
	
