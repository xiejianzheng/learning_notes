# log4j2输出配置：模式布局

PatternLayout是一个灵活的布局，可以使用模式配置。
这个类的目的是格式化日志事件并返回结果。
结果取决于转换模式。

转换模式与printf的转换模式有密切关系。一个转换模式由文本字面量和格式控制表达式（或称为转换说明符）组成。
注意任何字面量文本，包含特殊字符，都可以包含在转换模式中。如\t,\n,\r,\f。使用\\插入一个反斜杠。

每一个转换说明符以百分号%开始，后面跟可选的格式化修饰符和一个转换字符。
转换字符用于指定数据类型，例如：“类别”、“优先级”、“日期”、“线程名称”等。
格式化修饰符控制字段宽度、填充、左对齐、右对齐。

下面是一个简单例子：

让转换模式为:"%-5p[%t]:%m%n"

注意文本和转换说明符之间没有显式的分隔符。
模式解析器需要在他读到一个转换字符时知道它已经到达了一个转换说明符的尾端。

在上面的示例中，转换说明符%-5p表示日志事件的优先级需要左对齐，宽度为5。

如果模式字符串不包含一个用于处理Throwable如何进行日志的说明符，对模式的解析会像%xEx说明符已经被添加到了字符串尾部。
为了抑制完全抑制Throwable，在尾部简单添加%ex{0}作说明符。

## 模式列表

1. c{精度} logger{精度} 格式化日志名

输出产生日志事件的日志器名字。日志转换说明符后面可以跟一个可选的精度说明符，包含一个十进制整数或一个以十进制数开始的模式。

精度表示布局需要保留日志名多少个右边的日志名组件。

如 %c{1} 	保留一个： 日志名为 org.apache.commons.Foo   输出为: Foo
   %c{1.} 	保留一个，其他缩小为一个字母

2. d{模式} 
格式化日志事件的日期

%d{yyyy-MM-dd HH:mm:ss.SSS}

3. pid{} processID 
输出进程号

4. t tid threadId 
输出线程号

5. m msg 
输出日志事件对应的消息

6. n 
输出平台分隔符

7. p|level{level=label,level=label}
输出日志事件的级别。 你可以以"level=label,level=label"的形式，提供一个日志级别到值的映射，这值就会替代日志级别的名字显示出来。

例如: %level{WARN=W, DEBUG=D, ERROR=E, TRACE=T, INFO=I}

8. F file
输出是哪个文件产生这个日志事件的

9. L line
输出日志请求的发起行。


# log4j2 Appender说明

添加器是负责把LogEvent投递到他们的目的地的。
每一个添加器都需要实现Appender接口。
大多数添加器会从AbstractAppender处继承，并添加Lifecycle和Filterable接口的支持。

Lifecycle接口允许组件在配置完成后进行初始化，并且能在关闭时做清理工作。

Filterable接口允许组件支持过滤器附加到其身上，并在事件处理过程中执行。


添加器通常只负责将事件数据写入目。在大多数情况下他们会代理事件数据的格式化职责到布局组件。
一些添加器能包裹其他添加器。
他可以
1. 修改日志事件
2. 处理添加器中的故障
3. 根据高级筛选条件将事件路由到下级的添加器
4. 或者提供不直接格式化事件以供查看的类似功能

添加器总是有有一个名，这样它们就可以在日志器中被引用。

## AsyncAppender


# log4j2 全量异步化

-DLog4jContextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector

