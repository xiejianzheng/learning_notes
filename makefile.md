# makefile语法说明

## 变量
*变量*是makefile中定义的一个名字用来呈现一个文本字符串叫做*变量的值*。
**值可以被替换**通过显式请求，到目标、先决条件、配方或其他makefile部分中。
变量和函数在所有部分属于一个makefile都会被展开，当读时。除了在配方和右边关于变量定义使用“等号”，和身体属于变量定义使用define 指令。
变量可以表达列表关于文件名，选项们提交到编译器，程序们要运行，目录们要来找源文件，目录们用于输出，或其他你可以想象到的东西。

上LBM_LIB_DIR=$(KCBP_HOME)/lbm_oracle_debug                                                      │                                 
                                                                                               │include <文件路径> 
述文章说的，其实是————————变量代表着变量的值。

为了替换变量的值，需要写一个美元符号$在变量名字前面，并用圆括号或大括号把变量名字包起来）

这个也就是说，$(变量名), ${变量} 其实是个函数调用，替代变量的值用变量代表的字符串。
这个$的特殊含义，就是为什么你要在一个包含$符号的文件名或配方中，把$符号写成$$。

### 特殊的内置变量
* $@
代表目标

* $<
代表第一个依赖

* $^
代表所有依赖

* MAKEFILE_LIST
包含make解析到的每一个makefile的名字，按顺序哪个它们被解析到。
makefile的名字会被添加，仅在make解析这个makefile之前。
那也就是说你可以用
	$(lastword $(MAKEFILE_LIST))
来获取刚刚被include进来的makefile名字。


## 内部指令

include <文件路径>
将另一个makefile的内容包含进来

## 配方
一个规则的配方，包含一条或多条shell命令要执行的，一条一条，按它们出现的顺序。
通常，结果关于执行这些命令是目标关于这条规则被提升到今天。

用户可以使用不同的外壳程序，但是配方在makefile中总是被/bin/sh解析。除非makefile中指定了其他。

## 函数
函数们允许你做文本处理在makefile中，去计算文件列表用于操作，或命令列表在配方中使用的。
你在一个函数调用中使用函数，哪里你给了函数名和一些文本（函数参数列表）为了函数去操作。
函数的处理结果被替换到makefile发生调用的地方，就像变量被替换一样。

一个函数调用像变量引用一样。它能出现在任何变量引用能出现的地方。并且它的扩展规则与变量引用也一样。
${函数名 参数列表}
$(函数名 参数列表)

你也可以创建自己的函数，使用内置的call函数。

参数列表是函数的参数。它们可以用空格或tab按键来和函数名分隔。
如果参数列表中包含一个以上的参数，需要用“,”逗号分隔，所以，逗号，空格都不是参数的一部分。

用来环绕函数调用的分隔符，圆括号或大括号，在参数中只能成对出现，其他类型的分隔符可以单个出现。
如果参数列表它们包含其它函数调用或变量引用，最明智地是使用相同的分隔符来描述所有的引用。
如应该写：
	$(subst a,b,$(x))
而不是:
	$(subst a,b,${x}).

这是因为它是更清晰，并且因为只有一个类型的分隔符是被匹配到引用的结束。

写下的文本，为了每一个参数是被处理通过参数和函数替换去产生参数值，
哪一个是文本在哪个是函数会动作在上面。
替换被完成在顺序，哪个参数出现。

逗号和不匹配的括号，大括号不能出现在写下的参数文本中；
前置的空格不能出现在第一个参数的文本中。这些符号可以放到参数值中
通过变量替换。
首先定义变量comma和space，哪一个包含了单独的逗号和空格字符，
然后替换这些变量，哪里这些字符是需要的。像这样：

	comma:= ,
	empty:= 
	space:= $(empty) $(empty)
	foo:= a b c
	bar:= $(subst $(space),$(comma),$(foo))
	# bar is now'a,b,c'

这里subst函数替换每个空格用逗号，穿过foo的值，并且替换结果。


### 字符串替换和分析函数

* $(subst from,to,text)
执行一个文本替换在text上，每一个from的出现都会被替换成to。
结果被替换出来，为了函数调用。例如：
	$(subst ee,EE,feet on the street)
产生值“fEEt on the strEEt”。

* $(word, n,text)
返回text中的第n个单词。

* $(wordlist s,e,text)
返回单词列表在text中以第s个开始，第e个结束(包含)。
合理的值s，是从1开始的，e可能从0开始，如果s是大过文本中的单词数量，
结果值将是空。如果e是大于文本中的单词数目，到文本结束为止的单词将被返回。
如果s是大于e，则什么都不会返回。

* $(words text)
返回文本中的单词数量。
因此，文本中的最后一个单词是$(word, $(words text), text)
返回单词列表在text中以第s 单词个开始，第e个单词结束(包含)。
合理的值s值从1开始，e可以从0开始。
如：
	$(wordlist 2,3, foo bar baz)

返回 'bar baz'




















